# abst
dgl-ke というライブラリの document

https://dglke.dgl.ai/doc/kg.html

# memo

和訳かけながら読む

## Introduction to Knowledge Graph Embedding

ナレッジグラフ（KG）は、検索などのアプリケーションにおいて、異なるデータソースを統合し、基礎となる関係をモデル化する効果的な方法として登場した。 Amazonでは、商品間の階層関係、Amazon MusicやPrime Videoのクリエイターとコンテンツの関係、Alexaの質問応答サービスの情報などをKGで表現しています。 KGからエンベッディングの形で抽出された情報は、検索の改善、商品のレコメンド、不足情報の推論などに利用されています。

## What is a graph

グラフは物事とその関係を表すのに使われる構造である。 ノードの集合（頂点とも呼ばれる）とエッジの集合（弧とも呼ばれる）の2つで構成される。 各辺はノードのペアを結び、それらの間に関係があることを示す。 この関係には、ノード間の対称的な関係を表す無向性と、非対称的な関係を表す有向性がある。 例えば、グラフがソーシャルネットワークの人々の友好関係をモデル化するために使われる場合、エッジは2人が友人であることを示すために使われるので無向性となる。しかし、グラフがTwitterで人々がお互いをフォローし合う様子をモデル化するために使われる場合、エッジは有向性となる。 エッジの方向性によって、グラフは有向にも無向にもなる。

グラフには同種グラフと異種グラフがある。 同種グラフでは、すべてのノードは同じタイプのインスタンスを表し、すべてのエッジは同じタイプの関係を表す。 例えば、ソーシャル・ネットワークは、人々とそのつながりから構成されるグラフで、すべて同じエンティティ・タイプを表します。 対照的に、異種グラフでは、ノードとエッジは異なるタイプであり得る。 例えば、マーケットプレイスの情報をエンコードするためのグラフは、買い手、売り手、商品のノードを持ち、それらはwants-to-buy、has-bought、is-customer-of、is-sellingのエッジを介して接続される。

最後に、知識グラフにとって特に重要なもう一つのグラフのクラスは、マルチグラフである。 これは同じノードのペア間に複数の（有向）エッジを持つことができ、ループを含むこともできるグラフである。 これらの複数の辺は通常異なるタイプであり、ほとんどの多階グラフは異質である。 これらの多重辺や自己ループを許さないグラフは単純グラフと呼ばれる．

## What is a Knowledge Graph

先ほどのマーケットプレイスグラフの例では、異なるノードタイプ（買い手、売り手、商品）と異なる関係タイプ（wants-to-buy、has-bought、is-customer-of、is-selling）に割り当てられたラベルは、その特定のドメインでノードと関係が何を表すかについての正確な情報（しばしばセマンティクスと呼ばれる）を伝えます。 このグラフが入力されると、そのグラフは、含まれるノードと関係のタイプに関連する、その市場に関する知識をエンコードする。 このようなグラフは知識グラフの一例である。

知識グラフ(KG)は、ノードと関係タイプがドメイン固有のセマンティクスを持つ有向異種マルチグラフである。 KGを用いることで、知識を人間が解釈可能で、自動分析や推論に従順な形に符号化することができる。 KGは、さまざまなタイプのエンティティがさまざまなタイプの関係で接続された形で、多様なタイプの情報を表現するための一般的なアプローチになりつつある。

KGを扱う場合、グラフで使われる伝統的な頂点と辺とは異なる用語を採用する。 知識グラフの頂点はしばしばエンティティと呼ばれ、有向辺はしばしばトリプレットと呼ばれ、(h, r, t)タプルで表される。ここで、hは先頭のエンティティ、tは末尾のエンティティ、rは先頭と末尾のエンティティを関連付ける関係である。 ここでの関係という用語は、関係のタイプ（例えば、wants-to-buy、has-bought、is-customer-of、is-sellingのいずれか）を指すことに注意。 登場人物と彼らが住む世界を含む有向マルチグラフの例を見てみよう。

## What is the task of Knowledge Graph Embedding?

知識グラフ埋め込みは、既存のグラフ構造から欠けているアークを確率的に推論して知識グラフを完成させる作業である。 KGEは通常の関係推論とは異なり、知識グラフの情報は多関係であり、モデル化が複雑で計算コストがかかる。 このブログの残りの部分では、KGEの基礎について考察する。

## Common connectivity patterns:

KGでは、異なる接続性や関係パターンが一般的に観察される。 知識グラフ埋め込みモデルは、多くの場合、以下のタイプのいずれかである欠落した接続を予測することを意図しています。

- symmetric
- antisymmetric
- inversion
- composition
- example

refs: [RotatE: Knowledge Graph Embedding by Relational Rotation in Complex Space](https://arxiv.org/abs/1902.10197)

## Score Function

## A short explanation of the score functions

### TransE:
(ChatGpt)

TransEは、ナレッジグラフのエンベディングに使用されるシンプルで効果的なスコア関数です。ナレッジグラフにおけるエンベディングは、エンティティ（ノード）と関係（エッジ）を低次元のベクトル空間に埋め込む手法で、関係の性質を数値的に捉えようとするものです。TransEの主要な特徴は、エンティティと関係を加法的にモデル化する点です。

### TransEの基本的なアイデア:
- **エンティティと関係の埋め込み**: エンティティ（$h$や$t$）と関係（$r$）はベクトル空間に埋め込まれ、エンティティはベクトル$\mathbf{h}$や$\mathbf{t}$、関係はベクトル$\mathbf{r}$で表されます。
- **関係の表現**: TransEでは、関係$r$が「エンティティ$h$からエンティティ$t$への変換」として捉えられます。具体的には、関係$r$に対応するベクトル$\mathbf{r}$をエンティティ$h$のベクトル$\mathbf{h}$に加えることで、エンティティ$t$のベクトル$\mathbf{t}$に近づけます。すなわち、理想的な関係は以下の式で表されます：

 $$
  \mathbf{h} + \mathbf{r} \approx \mathbf{t}
 $$

- **スコア関数**: スコア関数は、エンティティと関係がどれだけ正しいかを評価します。具体的には、エンティティ$h$と関係$r$を通じて得られたベクトル$\mathbf{h} + \mathbf{r}$とエンティティ$t$のベクトル$\mathbf{t}$との距離を測り、その距離が小さいほど正しいと判断します。通常、L1またはL2ノルムを用いて距離を計算します：

 $$
  d(\mathbf{h} + \mathbf{r}, \mathbf{t}) = || \mathbf{h} + \mathbf{r} - \mathbf{t} ||
 $$

  この距離が小さいほど、トリプル$(h, r, t)$はナレッジグラフ上で有効な関係を表しているとみなされます。

### 特徴と限界:
- **特徴**:
  - モデルが非常にシンプルで計算効率が高い。
  - 線形関係を仮定しているため、関係の解釈が直感的でわかりやすい。

- **限界**:
  - 複雑な関係（対称関係、非対称関係、1対多、多対1、多対多など）を正確に表現するのは難しい。
  - すべての関係が線形であると仮定しているため、非線形な関係を扱うのが苦手。

TransEは、シンプルさと効率の良さから広く使われていますが、複雑な関係を扱う場合には他のモデル（TransH、TransR、DistMultなど）が用いられることも多いです。

TransRは、ナレッジグラフの埋め込み（embedding）手法の一つで、TransEの限界を克服するために開発されました。特に、**異なるタイプの関係を持つエンティティ**が、異なるベクトル空間で表現されるべきだという点に焦点を当てています。TransEでは、すべてのエンティティと関係が同じベクトル空間に埋め込まれるため、複雑な関係（多対1や1対多など）を十分に表現できない問題がありました。それを改善するのがTransRです。

### TransR:
(ChatGpt)

- **エンティティと関係の埋め込み**: TransRでは、エンティティと関係が**異なるベクトル空間**に埋め込まれます。具体的には、エンティティはエンティティ空間に埋め込まれ、関係は関係空間に埋め込まれます。これにより、関係ごとに異なる埋め込みが可能になり、複雑な関係をより柔軟に表現できます。

- **エンティティの関係空間への変換**: TransRの主要な考え方は、エンティティ空間から関係空間への**変換行列** $M_r$を使ってエンティティを関係空間に写像することです。エンティティ$h$や$t$はエンティティ空間でベクトル$\mathbf{h}$や$\mathbf{t}$で表されますが、関係$r$が存在する場合、それらは関係空間に次のように変換されます：

  $$
  \mathbf{h}_r = M_r \mathbf{h}, \quad \mathbf{t}_r = M_r \mathbf{t}
  $$

  ここで、$M_r$は関係$r$に特有の変換行列です。この変換により、関係ごとのエンティティ表現が適切にモデリングされます。

- **スコア関数**: TransEと同様に、TransRでは関係がエンティティ間の変換としてモデル化されます。関係$r$のベクトル$\mathbf{r}$と、変換後のエンティティベクトル$\mathbf{h}_r$と$\mathbf{t}_r$の距離がスコアとして計算されます。理想的な関係は以下のように表されます：

  $$
  \mathbf{h}_r + \mathbf{r} \approx \mathbf{t}_r
  $$

  これに基づいて、スコア関数はエンティティ$h$、関係$r$、エンティティ$t$の間の距離を以下のように計算します：

  $$
  d(\mathbf{h}_r + \mathbf{r}, \mathbf{t}_r) = || \mathbf{h}_r + \mathbf{r} - \mathbf{t}_r ||
  $$

  ここでも、L1またはL2ノルムを使って距離が計算され、距離が小さいほどトリプル$(h, r, t)$が正しい関係を示しているとみなされます。

### 特徴と利点:
- **関係ごとの空間**: TransEではエンティティと関係が同じ空間に埋め込まれるため、多対多や1対多、多対1の関係をうまく表現できませんでしたが、TransRでは関係ごとに異なる空間で埋め込むため、これらの複雑な関係をより正確に捉えることができます。

- **エンティティの異なる意味を関係に応じて表現**: 同じエンティティであっても、関係が異なれば、その役割や意味が変わることがあります。TransRは、関係に応じたエンティティの表現を変換することで、この違いを捉えられるようにしています。

### 限界:
- **計算コストの増加**: 関係ごとに変換行列を導入するため、TransEに比べて計算コストが高くなります。
- **変換行列の学習**: 変換行列$M_r$の学習が必要なため、モデルが複雑になるリスクがあります。

TransRは、TransEが抱える複雑な関係の表現の限界を解決し、異なる関係を持つエンティティ間の相互作用をより正確に捉えるための有力な手法です。

RESCALは、ナレッジグラフのエンベディング手法の一つで、特に**複雑な関係性**を捉えるために設計されています。RESCALは、エンティティ間のペアごとの相互作用を、**2次元のテンソル**を使ってモデリングすることで、各関係の意味をより豊かに表現できる点が特徴です。他の手法（TransEやTransRなど）に比べ、RESCALは関係の複雑さに対して非常に強力ですが、その分計算コストが高くなるという側面もあります。

### RESCALの基本的なアイデア:
- **エンティティと関係の埋め込み**: RESCALでは、各エンティティ $h$ と $t$ は、同じベクトル空間に埋め込まれ、それぞれベクトル $\mathbf{h}$、$\mathbf{t}$ として表されます。これらのエンティティ間の関係 $r$ は、単なるベクトルではなく、**行列 $R_r$** で表されます。

- **行列による関係表現**: RESCALでは、各関係 $r$ をエンティティ間の関係行列 $R_r$ で表現します。この行列 $R_r$ は、エンティティ間の相互作用を表現するための変換行列であり、特定の関係におけるエンティティ同士の相関を捉えます。具体的には、エンティティ $h$ と $t$ が関係 $r$ によってどのように相互作用するかを、行列 $R_r$ を用いて次のようにモデル化します：

 $$
  \mathbf{h}^\top R_r \mathbf{t}
  $$

  ここで、$\mathbf{h}$ と $\mathbf{t}$ はそれぞれエンティティ $h$ と $t$ の埋め込みベクトル、$R_r$ は関係 $r$ に対応する行列です。このモデルでは、エンティティベクトルが行列 $R_r$ によって変換され、他のエンティティとの相関を評価します。

### スコア関数:
RESCALのスコア関数は、エンティティ $h$ と $t$ のベクトル $\mathbf{h}$ と $\mathbf{t}$、および関係行列 $R_r$ を使って、以下のようにスコアを計算します：

$$
f(h, r, t) = \mathbf{h}^\top R_r \mathbf{t}
$$

このスコアは、エンティティ $h$ と $t$ が関係 $r$ においてどれだけ強く関連しているかを示すもので、スコアが高いほど、トリプル $(h, r, t)$ がナレッジグラフにおいて有効な関係であるとされます。

### 特徴と利点:
- **エンティティ間の相互作用を高次元で捉える**: RESCALでは関係を単なるベクトルとしてではなく、行列としてモデル化するため、エンティティ間の多様な相互作用を捉えることができます。これにより、複雑な関係性や多対多の関係など、他の手法では表現が難しいケースをうまく扱えます。

- **複雑な関係性のモデリング**: 関係ごとに異なる行列を用いることで、複雑で多様な関係性をよりリッチにモデリングすることが可能です。

### 限界:
- **計算コストが高い**: 各関係に対応する行列 $R_r$ の学習が必要であり、関係ごとにパラメータ数が多いため、計算コストが大きくなります。特に、関係の数が多くなると、行列のサイズが増加し、モデルの計算とメモリ負荷が大きくなります。

- **大規模グラフへの適用の難しさ**: パラメータの数が膨大になるため、大規模なナレッジグラフに適用する際には効率的な学習が難しく、メモリや計算時間の問題が発生します。

### まとめ:
RESCALは、ナレッジグラフのエンベディングにおいて、エンティティ間の複雑な関係を捉えるための強力な手法です。関係ごとの行列を使うことで、エンティティ間の多様な相互作用を表現できる点が大きな強みですが、その分計算コストが高く、大規模なナレッジグラフに適用する場合は効率的な処理が求められます。

## Training KE
